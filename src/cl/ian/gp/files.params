gp.fs.size = 1
gp.fs.0 = ec.gp.GPFunctionSet
gp.fs.0.name = f0
gp.fs.0.size = 11

# We have six functions in the function set:
gp.fs.0.func.0 = cl.ian.gp.nodes.Add
gp.fs.0.func.0.nc = nc2
gp.fs.0.func.1 = cl.ian.gp.nodes.Sub
gp.fs.0.func.1.nc = nc2
gp.fs.0.func.2 = cl.ian.gp.nodes.Mul
gp.fs.0.func.2.nc = nc2
gp.fs.0.func.3 = cl.ian.gp.nodes.Div
gp.fs.0.func.3.nc = nc2
gp.fs.0.func.4 = cl.ian.gp.nodes.Square
gp.fs.0.func.4.nc = nc1
gp.fs.0.func.5 = cl.ian.gp.nodes.Power
gp.fs.0.func.5.nc = nc2

# We have five terminals:
gp.fs.0.func.6 = cl.ian.gp.nodes.MyERC
gp.fs.0.func.6.nc = nc0
gp.fs.0.func.7 = cl.ian.gp.nodes.MeanVelocityTerminal
gp.fs.0.func.7.nc = nc0
gp.fs.0.func.8 = cl.ian.gp.nodes.DensityTerminal
gp.fs.0.func.8.nc = nc0
gp.fs.0.func.9 = cl.ian.gp.nodes.SeparationTerminal
gp.fs.0.func.9.nc = nc0
gp.fs.0.func.10 = cl.ian.gp.nodes.MeanReynoldsTerminal
gp.fs.0.func.10.nc = nc0

# The class of the problem
eval.problem = cl.ian.gp.PhenomenologicalModel
eval.problem.data = cl.ian.gp.PhenomenologicalData
eval.problem.stack = ec.gp.ADFStack
eval.problem.stack.context = ec.gp.ADFContext

pop.subpop.0.species.fitness = cl.ian.gp.HitLevelKozaFitness
pop.subpop.0.species.fitness.accepted-error = 5
pop.subpop.0.species.fitness.required-meeting-condition = 100

# Random segments used to test the individuals (500 elements dataset)
eval.problem.number-of-slices = 4

# Load input and output data for training
eval.problem.inputfile = $TrainingData/doe500train_sort.txt
eval.problem.outputfile = $TrainingData/salidas_P500train_sort.txt

# QRampedInit (modified ramped half/half tree building) parameters
gp.tc.0.init = cl.ian.gp.QRampedInit
# Min and Max level for initial individuals
gp.tc.0.init.min-depth = 2
gp.tc.0.init.max-depth = 6
gp.tc.0.init.growp = 0.5